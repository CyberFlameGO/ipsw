package ctf

import "math"

/*
 * CTF - Compact ANSI-C Type Format
 *
 * This file format can be used to compactly represent the information needed
 * by a debugger to interpret the ANSI-C types used by a given program.
 * Traditionally, this kind of information is generated by the compiler when
 * invoked with the -g flag and is stored in "stabs" strings or in the more
 * modern DWARF format.  CTF provides a representation of only the information
 * that is relevant to debugging a complex, optimized C program such as the
 * operating system kernel in a form that is significantly more compact than
 * the equivalent stabs or DWARF representation.  The format is data-model
 * independent, so consumers do not need different code depending on whether
 * they are 32-bit or 64-bit programs.  CTF assumes that a standard ELF symbol
 * table is available for use in the debugger, and uses the structure and data
 * of the symbol table to avoid storing redundant information.  The CTF data
 * may be compressed on disk or in memory, indicated by a bit in the header.
 * CTF may be interpreted in a raw disk file, or it may be stored in an ELF
 * section, typically named .SUNW_ctf.  Data structures are aligned so that
 * a raw CTF file or CTF ELF section may be manipulated using mmap(2).
 *
 * The CTF file or section itself has the following structure:
 *
 * +--------+--------+---------+----------+-------+--------+
 * |  file  |  type  |  data   | function | data  | string |
 * | header | labels | objects |   info   | types | table  |
 * +--------+--------+---------+----------+-------+--------+
 *
 * The file header stores a magic number and version information, encoding
 * flags, and the byte offset of each of the sections relative to the end of the
 * header itself.  If the CTF data has been uniquified against another set of
 * CTF data, a reference to that data also appears in the the header.  This
 * reference is the name of the label corresponding to the types uniquified
 * against.
 *
 * Following the header is a list of labels, used to group the types included in
 * the data types section.  Each label is accompanied by a type ID i.  A given
 * label refers to the group of types whose IDs are in the range [0, i].
 *
 * Data object and function records are stored in the same order as they appear
 * in the corresponding symbol table, except that symbols marked SHN_UNDEF are
 * not stored and symbols that have no type data are padded out with zeroes.
 * For each data object, the type ID (a small integer) is recorded.  For each
 * function, the type ID of the return type and argument types is recorded.
 *
 * The data types section is a list of variable size records that represent each
 * type, in order by their ID.  The types themselves form a directed graph,
 * where each node may contain one or more outgoing edges to other type nodes,
 * denoted by their ID.
 *
 * Strings are recorded as a string table ID (0 or 1) and a byte offset into the
 * string table.  String table 0 is the internal CTF string table.  String table
 * 1 is the external string table, which is the string table associated with the
 * ELF symbol table for this object.  CTF does not record any strings that are
 * already in the symbol table, and the CTF string table does not contain any
 * duplicated strings.
 *
 * If the CTF data has been merged with another parent CTF object, some outgoing
 * edges may refer to type nodes that exist in another CTF object.  The debugger
 * and libctf library are responsible for connecting the appropriate objects
 * together so that the full set of types can be explored and manipulated.
 */

const (
	CTF_MAGIC       = 0xcff1     /* magic number identifying header */
	CTF_MAX_TYPE    = 0xffff     /* max type identifier value */
	CTF_MAX_NAME    = 0x7fffffff /* max offset into a string table */
	CTF_MAX_VLEN    = 0x3ff      /* max struct, union, enum members or args */
	CTF_MAX_INTOFF  = 0xff       /* max offset of intrinsic value in bits */
	CTF_MAX_INTBITS = 0xffff     /* max size of an intrinsic in bits */
	/* See ctf_type_t */
	CTF_MAX_SIZE   = 0xfffe /* max size of a type in bytes */
	CTF_LSIZE_SENT = 0xffff /* sentinel for ctt_size */
	CTF_MAX_LSIZE  = math.MaxUint64
	/* data format version number */
	CTF_VERSION_1  = 1
	CTF_VERSION_2  = 2
	CTF_VERSION_3  = 3
	CTF_VERSION    = CTF_VERSION_3 /* current version */
	CTF_F_COMPRESS = 0x1           /* data buffer is compressed */
)

// ctf_preamble
type preamble struct {
	Magic   uint16 /* magic number (CTF_MAGIC) */
	Version uint8  /* data format version number (CTF_VERSION) */
	Flags   uint8  /* flags (see below) */
}

// ctf_header_t
type header_t struct {
	Preamble       preamble
	ParentLabelRef uint32 /* ref to name of parent lbl uniq'd against */
	ParentNameRef  uint32 /* ref to basename of parent */
	LabelOffset    uint32 /* offset of label section */
	ObjOffset      uint32 /* offset of object section */
	FuncOffset     uint32 /* offset of function section */
	TypeOffset     uint32 /* offset of type section */
	StrOffset      uint32 /* offset of string section */
	StrLen         uint32 /* length of string section in bytes */
}

type header struct {
	header_t
	ParentLabel string /* name of parent lbl uniq'd against */
	ParentName  string /* basename of parent */
}

// ctf_lblent_t
type lblent struct {
	Label     uint32 /* ref to name of label */
	TypeIndex uint32 /* last type associated with this label */
}

// ctf_stype_t
type stype struct {
	Name       uint32 /* reference to name in string table */
	Info       info   /* encoded kind, variant length (see below) */
	SizeOrType uint16 /* UNION {
	size of entire type in bytes
	reference to another type
	} */
}

/*
 * ctf_type_t
 * type sizes, measured in bytes, come in two flavors.  99% of them fit within
 * (USHRT_MAX - 1), and thus can be stored in the ctt_size member of a
 * ctf_stype_t.  The maximum value for these sizes is CTF_MAX_SIZE.  The sizes
 * larger than CTF_MAX_SIZE must be stored in the ctt_lsize member of a
 * ctf_type_t.  Use of this member is indicated by the presence of
 * CTF_LSIZE_SENT in ctt_size.
 */
type ctfType struct {
	Name       name   /* reference to name in string table */
	Info       info   /* encoded kind, variant length (see below) */
	SizeOrType uint16 /* UNION {
	size of entire type in bytes
	reference to another type
	} */
	LSizeHI uint32 /* high 32 bits of type size in bytes */
	LSizeLO uint32 /* low 32 bits of type size in bytes */
}

type info uint16

func (i info) Kind() kind {
	return kind((i & 0xf800) >> 11)
}
func (i info) IsRoot() bool {
	return ((i & 0x0400) >> 10) != 0
}
func (i info) VarLen() uint16 {
	return uint16(i) & CTF_MAX_VLEN
}

type name uint32

func (n name) StrID() uint32 {
	return uint32(n >> 31)
}
func (n name) NameOffset() uint32 {
	return uint32(n & 0x7fffffff)
}

type kind uint16

const (
	/*
	 * Values for CTF_TYPE_KIND().  If the kind has an associated data list,
	 * CTF_INFO_VLEN() will extract the number of elements in the list, and
	 * the type of each element is shown in the comments below.
	 */
	UNKNOWN  kind = 0 /* unknown type (used for padding) */
	INTEGER  kind = 1 /* variant data is CTF_INT_DATA() (see below) */
	FLOAT    kind = 2 /* variant data is CTF_FP_DATA() (see below) */
	POINTER  kind = 3 /* ctt_type is referenced type */
	ARRAY    kind = 4 /* variant data is single ctf_array_t */
	FUNCTION kind = 5 /* ctt_type is return type, variant data is */
	/* list of argument types (uint16_t's) */
	STRUCT   kind = 6  /* variant data is list of ctf_member_t's */
	UNION    kind = 7  /* variant data is list of ctf_member_t's */
	ENUM     kind = 8  /* variant data is list of ctf_enum_t's */
	FORWARD  kind = 9  /* no additional data; ctt_name is tag */
	TYPEDEF  kind = 10 /* ctt_type is referenced type */
	VOLATILE kind = 11 /* ctt_type is base type */
	CONST    kind = 12 /* ctt_type is base type */
	RESTRICT kind = 13 /* ctt_type is base type */

	PTRAUTH kind = 14 /* variant data is CTF_PTRAUTH_DATA (see below) */

	MAX kind = 31 /* Maximum possible CTF_K_* value */
)

// ctf_array_t
type array struct {
	Contents    uint16 /* reference to type of array contents */
	Index       uint16 /* reference to type of array index */
	NumElements uint32 /* number of elements */
}

/*
 * Most structure members have bit offsets that can be expressed using a
 * short.  Some don't.  ctf_member_t is used for structs which cannot
 * contain any of these large offsets, whereas ctf_lmember_t is used in the
 * latter case.  If ctt_size for a given struct is >= 8192 bytes, all members
 * will be stored as type ctf_lmember_t.
 */
const CTF_LSTRUCT_THRESH = 8192

// ctf_member_t
type member struct {
	Name   uint32 /* reference to name in string table */
	Type   uint16 /* reference to type of member */
	Offset uint16 /* offset of this member in bits */
}

// ctf_lmember_t
type lmember struct {
	Name     uint32 /* reference to name in string table */
	Type     uint16 /* reference to type of member */
	Pad      uint16 /* padding */
	OffsetHI uint32 /* high 32 bits of member offset in bits */
	OffsetLO uint32 /* low 32 bits of member offset in bits */
}

func (l lmember) Offset() uint64 {
	return uint64(l.OffsetHI)<<32 | uint64(l.OffsetLO)
}

// ctf_enum_t
type enum struct {
	Name  uint32 /* reference to name in string table */
	Value int32  /* value associated with this name */
}

type data struct {
}
